1.	Generate RSA Private Key:
openssl genpkey -algorithm RSA -out private_key.pem -aes256

2.	Extract RSA Public Key from Private Key:
openssl rsa -pubout -in private_key.pem -out public_key.pem

3.	Encrypt Data using RSA Public Key:
openssl rsautl -encrypt -pubin -inkey public_key.pem -in plaintext.txt -out encrypted_data.enc

4.	Decrypt Data using RSA Private Key:
openssl rsautl -decrypt -inkey private_key.pem -in encrypted_data.enc -out decrypted_data.txt


To generate RSA key pair using OpenSSL:
openssl genpkey -algorithm RSA -out private_key.pem -aes256 -pass pass:password

To extract the public key from the private key:
openssl rsa -in private_key.pem -pubout -out public_key.pem

To generate a digital signature using OpenSSL:
openssl dgst -sha256 -sign private_key.pem -out signature.sha256 data.txt

To verify a digital signature using OpenSSL:
openssl dgst -sha256 -verify public_key.pem -signature signature.sha256 data.txt


Certainly! To encrypt or decrypt using AES with OpenSSL, you can use the following commands in your terminal:

1. Encrypt:
   bash
   openssl enc -aes-256-cbc -in plaintext.txt -out encrypted.txt

   Replace plaintext.txt with the name of your input file and encrypted.txt with the desired name for the output encrypted file.

2. Decrypt:
   bash
   openssl enc -aes-256-cbc -d -in encrypted.txt -out decrypted.txt


   Replace encrypted.txt with the name of your encrypted file and decrypted.txt with the desired name for the output decrypted file.

Make sure to replace the file names and paths as needed for your specific use case. Additionally, you may need to provide a passphrase or key depending on your security requirements.

Certainly! DES (Data Encryption Standard) is an older symmetric encryption algorithm. Here are examples for encryption and decryption using DES with OpenSSL:



1. Encrypt:
   bash
   openssl enc -des-cbc -in plaintext.txt -out encrypted_des.txt


   Replace plaintext.txt with the name of your input file and encrypted_des.txt with the desired name for the output encrypted file.

2. Decrypt:
   bash
   openssl enc -des-cbc -d -in encrypted_des.txt -out decrypted_des.txt


   Replace encrypted_des.txt with the name of your encrypted file and decrypted_des.txt with the desired name for the output decrypted file.

Similar to AES, you may need to provide a passphrase or key depending on your security requirements. Keep in mind that DES is considered insecure for many modern applications, and you might want to consider more secure algorithms like AES if possible.




1.	Generate MD5 Hash:
openssl md5 filename.txt


2.	Generate SHA-256 Hash:
openssl sha256 filename.txt




Generate DH Parameters: First, generate the Diffie-Hellman parameters if you haven't already done so.
openssl dhparam -out dhparams.pem 2048

Generate Private Key and Public Key for Party A: Generate the private key and corresponding public key for Party A.

openssl genpkey -paramfile dhparams.pem -out partyA_key.pem
openssl pkey -in partyA_key.pem -pubout -out partyA_pubkey.pem

Generate Private Key and Public Key for Party B: Similarly, generate the private key and corresponding public key for Party B.

openssl genpkey -paramfile dhparams.pem -out partyB_key.pem
openssl pkey -in partyB_key.pem -pubout -out partyB_pubkey.pem

Exchange Public Keys: Exchange public keys between Party A and Party B securely.Derive Shared Secret for Party A: Party A computes the shared secret using their private key and Party B's public key.
openssl pkeyutl -derive -inkey partyA_key.pem -peerkey partyB_pubkey.pem -out shared_secret.bin

Derive Shared Secret for Party B: Party B computes the shared secret using their private key and Party A's public key.
openssl pkeyutl -derive -inkey partyB_key.pem -peerkey partyA_pubkey.pem -out shared_secret.bin

////////////////////////////////
import java.util.Scanner;

public class DiffieHillmanNormal {
    public static void main(String[] args) {
        long n=13;
        long g=6;
        long prA=5;
        long prB=4;
        long pubA=2;
        long pubB=9;
        long sharedA=modPow(pubB,prA,n);
        long sharedB=modPow(pubA, prB,n);
        System.out.println(sharedB+", "+sharedA);

    }

    private static long acceptLong() {
        Scanner sc =new Scanner(System.in);
        System.out.println("Enter Long:\n");
        return sc.nextLong();
    }

    private static long modPow(long base, long exp, long modulus) {
        long result = 1;
        while (exp > 0) {
            if(exp%2==1){
                result=(result*base)%modulus;
                exp--;
            }
            else{
                base=(base*base)%modulus;
                exp/=2;

            }

        }
        return result;
    }
}

////////////////////////////////
public class RsaNormal {
    public static void main(String[] args) {
        int p = 5, q = 17;
        int n = p * q;
        int m = (p - 1) * (q - 1);
        System.out.println("m=" + m);
        int e = 0;
        for (int i = 2; i < m; i++) {
            if (gcd(i, m) == 1) {
                e = i;
                break;
            }
        }
        e = 5;
        int d = modInverse(e, m);
        System.out.println("e=" + e);
        System.out.println("d=" + d);
        int input = 7;
        int encrypted = modPow(input, e, n);
        System.out.println("encrypted=" + encrypted);
        int decrypted = modPow(encrypted, d, n);
        System.out.println("decrypted=" + decrypted);
    }

    private static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    private static int modInverse(int b, int m) {
        int k=m;
        //find b inverse mod m
        int q=0,t1=0,t2=1,t3=0,r=0;
        while(b>0){
            q=m/b;
            r=m%b;
            t3=t1-(q*t2);
            t1=t2;
            t2=t3;
            m=b;
            b=r;

        }
        if(t1<0){
            t1+=k;
        }
        return t1;
    }

    private static int modPow(int base, int exp, int modulus) {
        int result = 1;
        while (exp > 0) {
            if(exp%2==1){
                result=(result*base)%modulus;
                exp--;
            }
            else{
                base=(base*base)%modulus;
                exp/=2;

            }

        }
        return result;
    }
}
////////////////////////////////
////////////////////////////////


import java.io.UnsupportedEncodingException;
import java.security.*;
import java.util.Base64;
import java.util.Scanner;

public class DigitalSignature {
    public static KeyPair generateKeyPair() {
        try {

            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            return keyPairGenerator.generateKeyPair();

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }
    private static boolean verifyDigitalSignature(byte[] input, byte[] hashedSignedMessage, KeyPair keyPair) {
        try {

            Signature signature = Signature.getInstance("MD5withRSA");
            signature.initVerify(keyPair.getPublic());
            signature.update(input);
            return signature.verify(hashedSignedMessage);

        }
        catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    private static byte[] hashSignMessage(byte[] input, KeyPair keyPair) {
        try {

            Signature signature = Signature.getInstance("MD5withRSA");
            signature.initSign(keyPair.getPrivate());
            signature.update(input);
            return signature.sign();
        }
        catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static byte[] acceptInput() {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter message:");
        String inputString = sc.next();
        try {
            return inputString.getBytes("UTF-8");
        } catch (Exception e) {
            // Handle exception
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        KeyPair keyPair = generateKeyPair();
        byte[] input = null;
        byte[] hashed_signed_message = null;

        int ch = 0;
        do {
            System.out.println("Enter:\n1.Sender's Side: for sending message\n2. Receiver's Side: for verifying digital signature\n3. Exit");
            ch = sc.nextInt();
            switch (ch) {
                case 1:
                    input = acceptInput();
                    hashed_signed_message = hashSignMessage(input, keyPair);
                    System.out.println("Sent message: " + Base64.getEncoder().encodeToString(hashed_signed_message));
                    break;
                case 2:
                    if (input == null) {
                        System.out.println("No message sent yet. Please send a message first.");
                        break;
                    }

                    System.out.println("Enter received text:");
                    String received = sc.next();
                    byte[] receivedBytes = Base64.getDecoder().decode(received);
                    boolean result = verifyDigitalSignature(input, receivedBytes, keyPair);
                    System.out.println("Digital signature is valid: " + result);
                    break;

                case 3:
                    System.out.println("Exiting");
                    break;
            }
        } while (ch != 3);
    }


}


///////////////////////////////////////////////////////////////////////////////////////////

import java.security.*;

public class MD5_SHA{

    public static void main(String[] args) {
        String original = "Hello";
        String hash = getMD5(original);
        System.out.println("Hash: " + hash);
    }

    public static String getMD5(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA");
            byte[] bytes = md.digest(input.getBytes());
            StringBuilder sb = new StringBuilder();
            for (byte b : bytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }
}




import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.Base64;

import javax.crypto.Cipher;

public class RSA {

    public static void main(String[] args) throws Exception {

        KeyPair keyPair = generateKeyPair();
        PublicKey publicKey = keyPair.getPublic();
        PrivateKey privateKey = keyPair.getPrivate();


        String originalMessage = "Hello, RSA!";
        byte[] encryptedBytes = encrypt(originalMessage, publicKey);


        String decryptedMessage = decrypt(encryptedBytes, privateKey);


        System.out.println("Original Message: " + originalMessage);
        System.out.println("Encrypted Message: " + Base64.getEncoder().encodeToString(encryptedBytes));
        System.out.println("Decrypted Message: " + decryptedMessage);
    }

    // Function to generate RSA Key Pair
    public static KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        return keyPairGenerator.generateKeyPair();
    }

    // Function to encrypt message using RSA Public Key
    public static byte[] encrypt(String message, PublicKey publicKey) throws Exception {
        // Perform encryption
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        return cipher.doFinal(message.getBytes());
    }

    // Function to decrypt message using RSA Private Key
    public static String decrypt(byte[] encryptedMessage, PrivateKey privateKey) throws Exception {
        // Perform decryption
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return new String(cipher.doFinal(encryptedMessage));
    }
}


/////////////////////////////////////////////////////////////////////////////////////

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;
import java.util.Scanner;

public class AES {

    private static final String ALGORITHM = "AES";
    private static final byte[] keyValue =
            new byte[] { 'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'T', 'h', 'i', 's', 'I', 's', 'A', 'S'};

    public static String encrypt(String data) {
        try {
            SecretKeySpec key = new SecretKeySpec(keyValue, ALGORITHM);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encryptedBytes = cipher.doFinal(data.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
        }
        catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String decrypt(String encryptedData) {
        try {
            SecretKeySpec key = new SecretKeySpec(keyValue, ALGORITHM);
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, key);
            byte[] decodedBytes = Base64.getDecoder().decode(encryptedData);
            byte[] decryptedBytes = cipher.doFinal(decodedBytes);
            return new String(decryptedBytes);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int choice;

        do {
            System.out.println("Enter:\n1. Sender's Side\n2. Receiver's Side\n3. Exit");
            choice = scanner.nextInt();
            scanner.nextLine();

            switch (choice) {
                case 1:
                    System.out.println("Enter data to encrypt:");
                    String data = scanner.nextLine();
                    String encryptedData = AES.encrypt(data);
                    System.out.println("Encrypted Data: " + encryptedData);
                    break;
                case 2:
                    System.out.println("Enter encrypted data to decrypt:");
                    String encrypted = scanner.next();
                    String decryptedData = AES.decrypt(encrypted);
                    System.out.println("Decrypted Data: " + decryptedData);
                    break;
                case 3:
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice!");
            }
        } while (choice != 3);
    }

}


//////////////////////////////////////////////////////////////////

import java.util.HashMap;
import java.util.Scanner;
public class HillCipher2 {
    public static void main(String[] args) {
        HashMap<Integer, Integer> map= inversemap();
        char[] letters = {
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        };

        int[][] key={
                {3,10,20},
                {20,9,17},
                {9,4,17}
        };
        String input=acceptInput();
        int[][] inputmatrix= createinputmatrix(input);
        int[][] keymatrix=inputMatrix(map);
        System.out.println("\nInput matrix");
        printMatrix(inputmatrix);
        System.out.println("\nKey matrix");
        printMatrix(keymatrix);
        int[][] ciphertext=multiply(inputmatrix, keymatrix);
        System.out.println("\nCipher matrix");
        printMatrix(ciphertext);
        System.out.println("\nCipher Text");
        printText(ciphertext, letters);
        int[][] decryptedmatrix= decrypt(ciphertext, keymatrix,map);
        System.out.println("\nDecrypted text");
        printText(decryptedmatrix, letters);




    }

    private static int[][] decrypt(int[][] ciphertext, int[][] keymatrix, HashMap<Integer, Integer> map) {
        int[][] inverse= inverse(ciphertext, keymatrix, map);
        int[][] ans=multiply(ciphertext, inverse);
        return ans;
    }

    private static void printText(int[][] matrix, char[] letters) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(letters[matrix[i][j]]+ " ");
            }

        }

    }

    private static int[][] inverse(int[][] c,int[][] keymatrix, HashMap<Integer, Integer> map) {
        int k = map.get(calculateDet(keymatrix));
        int[][] t= transposeMatrix(keymatrix);
        int [][] adj=adjoint(t);
        for(int i=0;i<3;i++){
            for(int j=0; j<3;j++){
                adj[i][j]*=k;
                adj[i][j]=adj[i][j]%26;
                if(adj[i][j]<0){adj[i][j]+=26;}

            }
        }
        return adj;


    }

    private static int[][] adjoint(int[][] t) {
        int[][] a= new int[3][3];
        for(int i=0;i<3;i++){
            for(int j=0; j<3;j++){
                a[i][j]=minor(t,i,j);
                if((i+j)%2==1){a[i][j]*=(-1);}
            }
        }
        return a;
    }

    private static int minor(int[][] t, int row, int col) {
        int[][] minorMatrix = new int[2][2];
        int a=0,b=0;
        for(int i=0;i<3;i++){
            if(i==row){continue;}
            for(int j=0; j<3;j++){
                if(j==col){continue;}
                minorMatrix[a][b]=t[i][j];
                if(a==0 && b==0){ a=0; b=1;}
                else if(a==0 && b==1){a=1;b=0;}
                else if(a==1 && b==0){a=1;b=1;}

            }

        }
        return minorMatrix[0][0] * minorMatrix[1][1] - minorMatrix[0][1] * minorMatrix[1][0];
        }



    private static int[][] transposeMatrix(int[][] keymatrix) {
        int[][] t= new int[3][3];
        for(int i=0;i<3;i++){
            for(int j=0; j<3;j++){
                t[j][i]=keymatrix[i][j];
            }
        }
        return t;
    }




    private static int[][] multiply(int[][] a, int[][] b) {
        int[][] ans= new int[3][3];
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                for(int k=0;k<3;k++){
                    ans[i][j]+=a[i][k]*b[k][j];
                    ans[i][j]=ans[i][j]%26;

                }

            }        }
        return ans;

    }

    public static int[][] createinputmatrix(String input) {
        int[][] m = new int[3][3];
        for (int i = 0; i < 9; i++) {
            m[i/3][i%3]= (int)input.charAt(i)-65;
        }
        return m;
    }

    private static HashMap<Integer, Integer> inversemap() {
        HashMap<Integer, Integer> map= new HashMap();
        map.put(1,1);
        map.put(3,9);
        map.put(5,21);
        map.put(9,3);
        map.put(21,5);
        map.put(7,15);
        map.put(15,7);
        map.put(11,19);
        map.put(19,11);
        map.put(17,23);
        map.put(23,17);
        map.put(25,25);
        return map;

    }

    public static int[][] inputMatrix(HashMap<Integer, Integer> map) {
        int[][] matrix = new int[3][3];
        System.out.println("Enter 3x3 matrix such that det!=0 and inverse of determinant mod 26 exists");
        boolean validmatrix=false;
        while(validmatrix==false){
            Scanner scanner = new Scanner(System.in);
            System.out.println("Enter the elements of the 3x3 matrix:");
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    matrix[i][j] = scanner.nextInt();
                }
            }
            int det=calculateDet(matrix);
            if(det!=0 && inversemap().containsKey(det)){
                validmatrix=true;
            }
        }

        return matrix;
    }

    private static int calculateDet(int[][] m){
        int ans=0;
        ans = (m[0][0]*(m[1][1]*m[2][2]-m[2][1]*m[1][2]))-(m[0][1]*(m[1][0]*m[2][2]
                -m[2][0]*m[1][2]))+(m[0][2]*(m[1][0]*m[2][1]-m[2][0]*m[1][1]));
        ans=ans%26;
        if(ans<0){ans+=26;}
        //
        return ans;
    }
    private static String acceptInput() {
        String input="";
        boolean correctinput=false;
        while(correctinput==false){
            Scanner sc= new Scanner(System.in);
            System.out.println("Enter input string (9 length and capital letters)");
            input=sc.next();
            boolean uppercase=true;
            for(int i=0;i<input.length();i++){
                if(!Character.isUpperCase(input.charAt(i))){
                    uppercase=false;
                    break;
                }
            }
            if(uppercase=true && input.length()==9){
                correctinput=true;
            }
        }
        return input;
    }
    public static void printMatrix(int[][] matrix) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }
}
/////////////////////////////////////////////////////////////////////


import java.util.*;

public class Playfair {
    public static void main(String[] args) {
        char[] capitalLetters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        playfair(capitalLetters);

    }

    public static void playfair(char[] capitalLetters) {
        String input = acceptInput();
        String finalinput = processInput(input);
        System.out.println("Processed input = " + finalinput);
        String key = acceptKey();
        char[][] m = createMatrix(key, capitalLetters);
        String encrypted = encrypt(finalinput, m);
        System.out.println("ENCRYPTED TEXT = "+encrypted);
        String decrypted = decrypt(encrypted, m);
        System.out.println("DECRYPTED TEXT = "+decrypted);

    }

    public static String decrypt(String input, char[][] m){
        StringBuilder ans= new StringBuilder();
        for(int i=0; i<=input.length()-2; i=i+2){
            int c1_row= findRow(input.charAt(i),m);
            int c1_col=findCol(input.charAt(i),m);
            int c2_row= findRow(input.charAt(i+1),m);
            int c2_col=findCol(input.charAt(i+1),m);

            int newc1col = (c1_col-1)%5;
            if(newc1col<0){newc1col+=5;}
            int newc2col = (c2_col-1)%5;
            if(newc2col<0){newc2col+=5;}
            int newc1row=(c1_row-1)%5;
            if(newc1row<0){newc1row+=5;}
            int newc2row=(c2_row-1)%5;
            if(newc2row<0){newc2row+=5;}

            if(c1_row==c2_row){

                ans.append(m[c1_row][newc1col]);
                ans.append(m[c2_row][newc2col]);
            }
            else if(c1_col==c2_col){
                ans.append(m[newc1row][c1_col]);
                ans.append(m[newc2row][c2_col]);

            }
            else{
                ans.append(m[c1_row][c2_col]);
                ans.append(m[c2_row][c1_col]);

            }

//            System.out.println(input.charAt(i)+" "+input.charAt(i+1));
//            System.out.println(ans.toString());
        }
        return ans.toString();

    }

    public static String encrypt(String input, char[][] m){
        StringBuilder ans= new StringBuilder();
        for(int i=0; i<=input.length()-2; i=i+2){
            int c1_row= findRow(input.charAt(i),m);
            int c1_col=findCol(input.charAt(i),m);
            int c2_row= findRow(input.charAt(i+1),m);
            int c2_col=findCol(input.charAt(i+1),m);
            if(c1_row==c2_row){
               ans.append(m[c1_row][(c1_col+1)%5]);
               ans.append(m[c2_row][(c2_col+1)%5]);
            }
            else if(c1_col==c2_col){
                ans.append(m[(c1_row+1)%5][c1_col]);
                ans.append(m[(c2_row+1)%5][c2_col]);

            }
            else{
                ans.append(m[c1_row][c2_col]);
                ans.append(m[c2_row][c1_col]);

            }
//            System.out.println(input.charAt(i)+" "+input.charAt(i+1));
//            System.out.println(ans.toString());
        }
        return ans.toString();

    }

    private static boolean sameRow(int i, int i2, char[][] m, String input) {
        boolean ans=false;
        if(findRow(input.charAt(i),m)==findRow(input.charAt(i2),m)){
            ans=true;
        }
        return  ans;
    }

    private static boolean sameColumn(int i, int i2, char[][] m,  String input) {
        boolean ans=false;
        if(findCol(input.charAt(i),m)==findCol(input.charAt(i2),m)){
            ans=true;
        }
        return  ans;
    }

    private static int findRow(char c, char[][] m){
        int row=-1;
        for(int i=0;i<m.length;i++){
            for(int j=0;j<m[0].length;j++){
                if(m[i][j]==c){
                    row=i;
                }
            }
        }
        return row;

    }
    private static int findCol(char c, char[][] m){
        int col=-1;
        for(int i=0;i<m.length;i++){
            for(int j=0;j<m[0].length;j++){
                if(m[i][j]==c){
                    col=j;
                }

            }
        }
        return col;

    }

    private static char[][] createMatrix(String key, char[] capitalLetters) {
        char[][] m= new char[5][5];
        Set<Character> s = new LinkedHashSet<>();
        //adding key char to set
        for (int i=0; i<key.length();i++){
            s.add(key.charAt(i));
        }

        //adding rest chars to set
        for (int i=0; i< capitalLetters.length;i++){
            s.add(capitalLetters[i]);
        }

        int i=0; int j=0;
        for(char c: s){
            m[i/5][j%5]=c;
            i++;
            j++;
        }
        printCharArray(m);
        return m;

    }

    private static String processInput(String input) {
       StringBuilder ans= new StringBuilder();
       List<Character> ls= new LinkedList<>();
       int[] visited= new int[input.length()];
       int i=0;
       while(i<input.length()-1){
           if(input.charAt(i)!=input.charAt(i+1)){
               ans.append(input.charAt(i));
               visited[i]=1;
               ans.append(input.charAt(i+1));
               visited[i+1]=1;
               i=i+2;

           }
           else{
               ans.append(input.charAt(i));
               visited[i]=1;
               ans.append('X');
               i=i+1;
           }
       }
       if(visited[input.length()-1]==0){
           if(ans.length()%2==0){
               ans.append(input.charAt(input.length()-1));
               visited[input.length()-1]=1;
               ans.append('X');
           }
           else{
               ans.append('X');
           }
       }



       return ans.toString();
    }


    public static void printCharArray(char[][] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println(); // Move to the next line after printing each row
        }
    }

    public static String acceptKey() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String key (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Key = "+input);
        return input;

    }
    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput=true;
        for(int i=0; i<input.length(); i++){
            if(!Character.isUpperCase(input.charAt(i))){
                correctInput=false;
                break;
            }
        }
        return correctInput;

    }
}
////////////////////////////////////////////////////
import java.util.Scanner;

public class Railfence {
    public static void main(String[] args) {
        String input=acceptInput();
        int key=acceptKey();
        String encrypted=encrypt(input,key);
        System.out.println("ENCRYPTED TEXT = "+encrypted);
        String decrypted = decrypt(encrypted, key);
        System.out.println("DECRYPTED TEXT = "+decrypted);
    }

    private static String decrypt(String input, int key) {
        StringBuilder ans=new StringBuilder();
        int rows=key;
        int col=input.length();
        char[][] m= new char[rows][col];

        for(int i=0;i<rows;i++){
            for(int j=0;j<col;j++){
                m[i][j]='.';
            }
        }
        int c=0;
        int i=0;
        int n=input.length();
        boolean goUp=false;
        while(i<n){
            m[c][i]='+';
            if(c==0){goUp=false;}
            else if(c==key-1){goUp=true;}
            if(goUp){
                c--;
            }
            else{
                c++;
            }
            i++;
        }

        int w=0;
        for(int x=0; x<rows;x++){
            for(int y=0;y<col;y++){
                if(m[x][y]=='+'){
                    m[x][y]=input.charAt(w);
                    w++;
                }
            }
        }

        for(int y=0;y<col;y++){
            for(int x=0; x<rows;x++){
                if(m[x][y]!='.'){
                    ans.append(m[x][y]);

                }
            }
        }
        return ans.toString();

    }

    private static String encrypt(String input, int key) {
        StringBuilder ans=new StringBuilder();
        int rows=key;
        int col=input.length();
        char[][] m= new char[rows][col];

        for(int i=0;i<rows;i++){
            for(int j=0;j<col;j++){
                m[i][j]='.';
            }
        }
        int c=0;
        int i=0;
        int n=input.length();
        boolean goUp=false;
        while(i<n){
            m[c][i]=input.charAt(i);
            if(c==0){goUp=false;}
            else if(c==key-1){goUp=true;}
            if(goUp){
                c--;
            }
            else{
                c++;
            }
            i++;
        }
        printCharArray(m);
        for(int x=0; x<rows;x++){
            for(int y=0;y<col;y++){
                if(m[x][y]!='.'){
                    ans.append(m[x][y]);
                }
            }
        }
        return ans.toString();

    }
    public static void printCharArray(char[][] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println(); // Move to the next line after printing each row
        }
    }

    public static int acceptKey() {
        int key = 0;
        boolean correctKey = false;
        do {
            System.out.println("Enter Key (an integer):");
            Scanner sc = new Scanner(System.in);
            if (sc.hasNextInt()) {
                key = sc.nextInt();
                correctKey = true;
            } else {
                System.out.println("Invalid input. Key should be an integer.");
            }
        } while (!correctKey);
        System.out.println("Key = " + key);
        return key;
    }

    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput=true;
        for(int i=0; i<input.length(); i++){
            if(!Character.isUpperCase(input.charAt(i))){
                correctInput=false;
                break;
            }
        }
        return correctInput;

    }
}


///////////////////////////////////////////////////////////////
import java.util.Scanner;
public class Vigenere {
    public static void main(String[] args) {
        char[] capitalLetters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        vigenere(capitalLetters);
    }

    private static void vigenere(char[] capitalLetters) {
        String input = acceptInput();
        String key = acceptKey();
        String encrypted = encrypt(input, key, capitalLetters);
        System.out.println("ENCRYPTED TEXT = " + encrypted);
        String decrypted = decrypt(encrypted, key, capitalLetters);
        System.out.println("DECRYPTED TEXT = " + decrypted);
    }

    private static String decrypt(String input, String key, char[] capitalLetters) {
        StringBuilder ans = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char p = input.charAt(i);
            char k = key.charAt(i % key.length());
            int j = ((int) p - (int) k - 130) % 26;
            if (j < 0) {
                j += 26;
            }
            ans.append(capitalLetters[j]);

        }
        return ans.toString();
    }

    private static String encrypt(String input, String key, char[] capitalLetters) {
        StringBuilder ans = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char p = input.charAt(i);
            char k = key.charAt(i % key.length());
            int j = ((int) p + (int) k - 130) % 26;
            ans.append(capitalLetters[j]);

        }
        return ans.toString();
    }

    public static String acceptKey() {
        Scanner sc = new Scanner(System.in);
        boolean correctInput = false;
        String input = "";
        do {
            System.out.println("Enter String key (capital letters)  :");
            input = sc.next();
            if (checkInputCorrect(input)) {
                correctInput = true;
            }
        }
        while (!correctInput);
        System.out.println("Key = " + input);
        return input;

    }

    public static String acceptInput() {
        Scanner sc = new Scanner(System.in);
        boolean correctInput = false;
        String input = "";
        do {
            System.out.println("Enter String input (capital letters)  :");
            input = sc.next();
            if (checkInputCorrect(input)) {
                correctInput = true;
            }
        }
        while (!correctInput);
        System.out.println("Input = " + input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput = true;
        for (int i = 0; i < input.length(); i++) {
            if (!Character.isUpperCase(input.charAt(i))) {
                correctInput = false;
                break;
            }
        }
        return correctInput;
    }
}

///////////////////////////////////////////////

import java.util.Scanner;

public class Columnar {
    public static void main(String[] args) {
        String input=acceptInput();
        int[] key=acceptKey();
        columnar(input,key);
    }
    public  static void columnar(String input, int[] key){
        String encrypted= encrypt(key, input);
        String decrypted=decrypt(key, encrypted);
    }

    private static String decrypt(int[] key, String input) {
        StringBuilder ans= new StringBuilder();
        char[][] m= new char[input.length()/key.length][key.length];
        int rows=input.length()/ key.length;
        int n = key.length;

        for(int i=0;i< input.length();i++){
            int col=findCol((i/rows)+1,key);
            int row= i%rows;
            m[row][col]=input.charAt(i);
        }
        System.out.println();
        printCharArray(m);

        for(int i=0;i<rows;i++){
            for(int j=0;j<key.length;j++){
                ans.append(m[i][j]);
            }
        }
        String decrypted=ans.toString();
        System.out.println("Decrypted text = "+decrypted);
        return decrypted;

    }

    public static String encrypt(int[] key, String input){
        StringBuilder ans= new StringBuilder();
        int n=key.length;
        int rows=0;
        if(input.length() % n==0){
            rows=input.length()/n;
        }
        else{
            rows=input.length()/n +1;
        }
        int x=0;
        if(input.length()%n!=0){
            x= (n*((input.length()/n) +1))-input.length();

        }
        String input2=input;
        for(int i=0;i<x;i++){
            input2=input2+"X";
        }
//        System.out.println("Input becomes = "+input2);
//        System.out.println("new input length = "+input2.length());

        char[][] m= new char[rows][n];

        for(int i=0; i<input2.length();i++){
            m[i/n][i%n]=input2.charAt(i);
        }
//
        for(int i=0;i< key.length;i++){
            int col=findCol(i+1,key);
            for(int j=0; j<rows;j++){
                ans.append(m[j][col]);
            }
        }
        System.out.println("Encrypted text = "+ans.toString());
        return ans.toString();
    }

    private static int findCol(int j, int[] key) {
        int col=-1;
        for(int i=0;i< key.length;i++){
            if(key[i]==j){
                col=i;
                break;
            }
        }
        return col;
    }


    public static void printCharArray(char[][] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println(); // Move to the next line after printing each row
        }
    }
    public static int[] acceptKey(){
        Scanner sc= new Scanner(System.in);
        System.out.println("Enter number of columns");
        int n=sc.nextInt();
        int[] key=new int[n];
        System.out.println("Enter column numbers between 1 to "+n);
        for(int i=0; i<n;i++){
            key[i]=sc.nextInt();
        }
        return key;
    }
    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput=true;
        for(int i=0; i<input.length(); i++){
            if(!Character.isUpperCase(input.charAt(i))){
                correctInput=false;
                break;
            }
        }
        return correctInput;

    }
}
///////////////////////////////////////////////////
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class MultiplicativeCipher {
    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters)  :");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;

    }

    public static boolean checkInputCorrect(String input) {
        boolean correctInput=true;
        for(int i=0; i<input.length(); i++){
            if(!Character.isUpperCase(input.charAt(i))){
                correctInput=false;
                break;
            }
        }
        return correctInput;

    }

    public static int acceptKey(HashMap <Integer, Integer>  map) {

        boolean correctkey=false;
        int key=-1;
        do{
            System.out.println("Enter Key:");
            try{
                Scanner sc= new Scanner(System.in);
                key=sc.nextInt();
            }
            catch(Exception e){
                System.out.println("Key should be an integer with a multiplication inverse in mode 26. Try again.");

            }
            if(map.containsKey(key)||map.containsValue(key)){
                correctkey=true;

            }
        }
        while(!correctkey);
        System.out.println("Key = "+key);
        return key;


    }

    public static String encrypt(String input, int key, char[] capitalLetters) {
        StringBuilder ans = new StringBuilder();
        int n = input.length();
        for(int i=0; i<n; i++){
            int p = (int)input.charAt(i);
            int c =  ((p-65)*key)%26;
            ans.append(capitalLetters[c]);
        }
        String encrypted = ans.toString();
        System.out.println("Encrypted String = "+encrypted);
        return encrypted;

    }

    public static String decrypt(String input, int key, char[] capitalLetters) {
        StringBuilder ans = new StringBuilder();
        int n = input.length();
        for(int i=0; i<n; i++){
            int p = (int)input.charAt(i);
            int c =  ((p-65)*key)%26;
            if(c<0){
                c+=26;
            }
            ans.append(capitalLetters[c]);
        }
        String decrypted = ans.toString();
        System.out.println("Decrypted String = "+decrypted);
        return decrypted;
    }
    public static void multiplicativeCipher(HashMap <Integer, Integer>  map, char[] capitalLetters) {
        int key = acceptKey(map);
        String input= acceptInput();
        String encrypted = encrypt(input, key, capitalLetters);
        int dkey=-1;
        if(map.containsKey(key)){
            dkey=map.get(key);
        }
        else {
            for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                if(entry.getValue() == key){
                    dkey=entry.getKey();
                    break;
                }
            }
            if(dkey==-1){}
        }
        System.out.println("Decryption Key = "+dkey);
        String decrypted = decrypt(encrypted, dkey, capitalLetters);
    }

    public static void main(String[] args) {
        HashMap <Integer, Integer>  map = new HashMap<>();
        map.put(1,1);
        map.put(3,9);
        map.put(5,21);
        map.put(7,15);
        map.put(11,19);
        map.put(17,23);
        map.put(25,25);
        char[] capitalLetters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        multiplicativeCipher(map, capitalLetters);



    }
}
/////////////////////////////////////////////////////////////
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
public class AdditiveCipher {
    public static String acceptInput() {
        Scanner sc= new Scanner(System.in);
        boolean correctInput=false;
        String input="";
        do{
            System.out.println("Enter String input (capital letters):");
            input=sc.next();
            if(checkInputCorrect(input)){
                correctInput=true;
            }
        }
        while(!correctInput);
        System.out.println("Input = "+input);
        return input;
    }

    public static boolean checkInputCorrect(String input) {
        return input.matches("[A-Z]+");
    }

    public static int acceptKey() {
        int key = 0;
        boolean correctKey = false;
        do {
            System.out.println("Enter Key (an integer):");
            Scanner sc = new Scanner(System.in);
            if (sc.hasNextInt()) {
                key = sc.nextInt();
                correctKey = true;
            } else {
                System.out.println("Invalid input. Key should be an integer.");
            }
        } while (!correctKey);
        System.out.println("Key = " + key);
        return key;
    }

    public static String encrypt(String input, int key, char[] capitalLetters) {
        StringBuilder encryptedString = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char ch = input.charAt(i);
            int index = ch - 'A'; // Convert character to 0-based index
            int encryptedIndex = (index + key) % 26; // Apply the additive cipher formula
            if (encryptedIndex < 0) {
                encryptedIndex += 26; // Handle negative indices
            }
            encryptedString.append(capitalLetters[encryptedIndex]);
        }
        System.out.println("Encrypted String = " + encryptedString);
        return encryptedString.toString();
    }

    public static String decrypt(String input, int key, char[] capitalLetters) {
        StringBuilder decryptedString = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char ch = input.charAt(i);
            int index = ch - 'A'; // Convert character to 0-based index
            int decryptedIndex = (index - key) % 26; // Apply the additive cipher formula
            if (decryptedIndex < 0) {
                decryptedIndex += 26; // Handle negative indices
            }
            decryptedString.append(capitalLetters[decryptedIndex]);
        }
        System.out.println("Decrypted String = " + decryptedString);
        return decryptedString.toString();
    }

    public static void main(String[] args) {
        char[] capitalLetters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
        int key = acceptKey();
        String input = acceptInput();
        String encrypted = encrypt(input, key, capitalLetters);
        decrypt(encrypted, key, capitalLetters);
    }
}



